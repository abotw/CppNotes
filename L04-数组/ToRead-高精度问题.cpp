#include <iostream>

const int N = 10010;

using namespace std;


int main() {
    /*
    T: O() 外部循环为n次，也就是n的幂次，内部循环为数字的长度，也就是 n\log_{10}{2} ， 因此复杂度为 n * (n\log_{10}{2})
    S: O() 数字的长度  n\log_{10}{2}
    idea:
     构成要件：一个数组存储数字；一个全局变量记录进位【每次进位实质上就是将其向右移动一位】；一个局部变量。存储累乘，然后累加的数字；
     基本逻辑：近似于斐波那契数列的逻辑，每次乘以前面的数字，然后存储，这里累乘的是2，初始值是1；其中幂次n作为了外部循环
    */
    // 最低为数字是1，因为它乘以任何数都是任何数
    int a[N] = {1};
    int n;
    cin >> n;
    int m = 1;
    // 输入的 n 是 2 的幂次，并非乘数
    for (int i = 0; i < n; i++) {
        int t = 0;
        // 循环内的数字从低位不断被取出，这些数字都从左到右存放，也就是个位数在最左端，每次从数组a中读取个位十位，分别与 2 相乘
        // 运算后把数字存回原数组
        for (int j = 0; j < m; j++) {
            t += a[j] * 2;
            a[j] = t % 10;
            t /= 10;
        }
        // 负责进位，for循环最后一个操作是 t / 10，由于乘以2，最大为19， 因此若商为1，必定进位1
        if (t) a[m++] = 1;
    }

    for (int i = m - 1; i >= 0; i--) cout << a[i];

    return 0;
}

// 作者：yxc
// 链接：https://www.acwing.com/file_system/file/content/whole/index/content/395688/
// 来源：AcWing
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。